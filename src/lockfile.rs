use std::collections::BTreeMap;
use std::path::{Path, PathBuf};
use std::{
    fs::read_to_string,
    io::{self, BufWriter, Write},
};

use anyhow::Context;
use fs_err::File;
use semver::Version;
use serde::{Deserialize, Serialize};

use crate::package_origin::PackageOrigin;
use crate::package_source::PackageSourceId;
use crate::{
    manifest::Manifest, package_id::PackageId, package_name::PackageName, resolution::Resolve,
};

pub const LOCKFILE_NAME: &str = "wally.lock";

#[derive(Debug, Serialize, Deserialize)]
pub struct Lockfile {
    pub registry: String,

    #[serde(rename = "package")]
    pub packages: Vec<LockPackage>,
}

impl Lockfile {
    pub fn from_manifest(manifest: &Manifest) -> Self {
        Self {
            registry: manifest.package.registry.clone(),
            packages: Vec::new(),
        }
    }

    pub fn from_resolve(resolve: &Resolve) -> Self {
        let mut packages = Vec::new();

        for package_id in &resolve.activated {
            let dependencies = resolve
                .shared_dependencies
                .get(package_id)
                .map(|dependencies| {
                    dependencies
                        .iter()
                        .map(|(key, value)| (key.clone(), value.clone()))
                        .collect()
                })
                .unwrap_or_else(Vec::new);

            packages.push(match &resolve.metadata[package_id].package_origin {
                PackageOrigin::Registry(_) => LockPackage::Registry(RegistryLockPackage {
                    name: package_id.name().clone(),
                    version: package_id.version().clone(),
                    checksum: None,
                    dependencies,
                }),
                PackageOrigin::Path(path) => LockPackage::Path(PathLockPackage {
                    path: path.clone(),
                    dependencies,
                }),
                PackageOrigin::Git(_) => todo!(),
            });
        }

        Self {
            registry: "test".to_owned(),
            packages,
        }
    }

    pub fn load(project_path: &Path) -> anyhow::Result<Option<Self>> {
        let lockfile_path = project_path.join(LOCKFILE_NAME);
        let contents = match read_to_string(&lockfile_path) {
            Ok(contents) => contents,
            Err(err) => {
                if err.kind() == io::ErrorKind::NotFound {
                    return Ok(None);
                } else {
                    return Err(err.into());
                }
            }
        };
        Ok(Some(toml::from_str(&contents)?))
    }

    pub fn save(&self, project_path: &Path) -> anyhow::Result<()> {
        let lockfile_path = project_path.join(LOCKFILE_NAME);
        let serialized = toml::to_string(self)?;

        let mut file = BufWriter::new(File::create(lockfile_path)?);
        writeln!(file, "# This file is automatically @generated by Wally.")?;
        writeln!(file, "# It is not intended for manual editing.")?;
        write!(file, "{}", serialized)?;
        file.flush()?;

        Ok(())
    }

    pub fn get_try_to_use(&self) -> BTreeMap<PackageId, PackageOrigin> {
        let mut try_to_use = BTreeMap::new();

        for package in &self.packages {
            match package {
                LockPackage::Registry(registry_package) => {
                    try_to_use.insert(
                        PackageId::new(
                            registry_package.name.clone(),
                            registry_package.version.clone(),
                        ),
                        // TODO: Try using self.registry instead. I do not know how to make it work because it shouldn't be a string in the first place!
                        PackageOrigin::Registry(PackageSourceId::DefaultRegistry),
                    );
                }
                LockPackage::Path(path_package) => {
                    let path_package_manifest = Manifest::load(&path_package.path)
                        .context("Lockfile should not be wrong about package path.")
                        .unwrap();

                    let package_id = path_package_manifest.package_id();
                    try_to_use.insert(package_id, PackageOrigin::Path(path_package.path.clone()));
                }
                LockPackage::Git(_) => {}
            }
        }

        try_to_use
    }
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LockPackage {
    Registry(RegistryLockPackage),
    Git(GitLockPackage),
    Path(PathLockPackage),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct RegistryLockPackage {
    pub name: PackageName,
    pub version: Version,
    pub checksum: Option<String>,

    #[serde(default)]
    pub dependencies: Vec<(String, PackageId)>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PathLockPackage {
    pub path: PathBuf,

    #[serde(default)]
    pub dependencies: Vec<(String, PackageId)>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GitLockPackage {
    pub name: String,
    pub rev: String,
    pub commit: String,

    #[serde(default)]
    pub dependencies: Vec<(String, PackageId)>,
}
